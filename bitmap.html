<html>
<head>
  <style type="text/css">
    html, body { height: 100%; overflow: auto; }
    body { padding: 0; margin: 0; }
    #silverlightControlHost { height: 100%; text-align: center; }
  </style>
  <script type="text/javascript">
    window.DLR = {path: "bin3"}
    DLR.settings = { EnableGPUAcceleration: 'true', debug: true }
  </script>
  <script src="bin3/dlr.js" type="text/javascript"></script>
  <script type="text/python" src="repl.py" class="xaml"></script>
  <title>bitmap</title>
</head>
<body>

  <script type="application/xml+xaml" id="xaml" width="480" height="360" defer='true'>
  </script>

  <script type="text/python" class="xaml">
    import System
    from System.Windows.Controls import UserControl, Grid, Image
    from Microsoft.Scripting.Silverlight import DynamicApplication
    from System.Windows.Media import SolidColorBrush, Colors
    from System.Windows.Media.Imaging import WriteableBitmap
    from System import Math, Int32
    from System import TimeSpan
    from System.Windows.Threading import DispatcherTimer
    from System.Threading import ThreadPool, WaitCallback

    class Mandelbrot(UserControl):
      def __init__(self):
        self._max = 30
        self._escape = 20

        self._rmin = -.75;
        self._rmax = -.46;
        self._imin = -.65;
        self._imax = -.50;

        self.image = Image(Width = 480, Height = 360)
        grid = Grid(Background = SolidColorBrush(Colors.Black))
        grid.Children.Add(self.image)
        self.Content = grid

        print 'before generate'
        System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback(self.generate))
        #self.generate() 
        print 'after generate'

      def draw(self, data):
        print 'draw'
        output = WriteableBitmap(self.image.Width, self.image.Height)
        for i in range(data.Length):
          output.Pixels[i] = data[i]
        output.Invalidate()
        self.image.Source = output

      def generate(self):
        print 'generate'
        bmap = System.Array.CreateInstance(int, self.image.Width * self.image.Height)
     
        # Compute increments for real and imaginary components
        dr = (self._rmax - self._rmin) / (self.image.Width - 1)
        di = (self._imax - self._imin) / (self.image.Height - 1)
     
        # Check each pixel for inclusion in the Mandelbrot set
        for x in range(int(self.image.Width)):
          cr = self._rmin + (x * dr)
          for y in range(int(self.image.Height)):
            ci = self._imin + (y * di)
            zr = cr
            zi = ci
            count = 0

            while count < self._max:
              zr2 = zr * zr
              zi2 = zi * zi

              if zr2 + zi2 > self._escape:
                bmap[(y * self.image.Width) + x] = Math.Pow(count + 1, 5) % Int32.MaxValue
                break

              zi = ci + (2.0 * zr * zi)
              zr = cr + zr2 - zi2
              count += 1

            if count == self._max:
              bmap[(y * self.image.Width) + x] = 0 # Black

        self.image.Dispatcher.BeginInvoke(System.Action[bmap.GetType()](self.draw), bmap)
        #self.draw(bmap)
        
 
    DynamicApplication.Current.RootVisual = Mandelbrot()
  </script>

</body>
</html>
